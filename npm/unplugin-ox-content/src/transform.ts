/**
 * Markdown transformation logic for unplugin-ox-content.
 *
 * Uses Rust-based parser via NAPI bindings for optimal performance.
 */

import type { ResolvedOptions, TransformResult, TocEntry } from './types';

/**
 * Transforms Markdown content into a JavaScript module.
 * Uses Rust-based renderer via NAPI bindings for optimal performance.
 *
 * Note: This requires the @ox-content/napi package to be built.
 * NAPI bindings are loaded dynamically to support both Node.js and build-time execution.
 */
export async function transformMarkdown(
  source: string,
  filePath: string,
  options: ResolvedOptions
): Promise<TransformResult> {
  // Dynamically import NAPI bindings
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let napi: any;
  try {
    // @ts-ignore NAPI bindings are loaded dynamically from Rust
    napi = await import('@ox-content/napi');
  } catch (error) {
    throw new Error(
      '[ox-content] Failed to load @ox-content/napi. Please ensure the NAPI module is built. ' +
      'Run: pnpm build:napi'
    );
  }

  // Call Rust-based transformation
  const result = napi.transform(source, {
    gfm: options.gfm,
    footnotes: options.footnotes,
    task_lists: options.taskLists,
    tables: options.tables,
    strikethrough: options.strikethrough,
    toc_max_depth: options.tocMaxDepth,
  });

  if (result.errors.length > 0) {
    console.warn('[ox-content] Transform warnings:', result.errors);
  }

  // Parse frontmatter from JSON
  let frontmatter: Record<string, unknown>;
  try {
    frontmatter = JSON.parse(result.frontmatter);
  } catch {
    frontmatter = {};
  }

  // Convert flat TOC from Rust to nested TOC
  const flatToc: TocEntry[] = result.toc.map((item: { depth: number; text: string; slug: string }) => ({
    ...item,
    children: [],
  }));
  const toc = options.toc ? buildTocTree(flatToc) : [];

  // Apply ox-content native plugins for post-processing
  let html = result.html;
  for (const plugin of options.plugin.oxContent) {
    html = await plugin(html);
  }

  // Generate JavaScript module code
  const code = generateModuleCode(html, frontmatter, toc, filePath);

  return {
    code,
    html,
    frontmatter,
    toc,
  };
}

/**
 * Builds nested TOC tree from flat list.
 */
function buildTocTree(
  entries: Array<{ depth: number; text: string; slug: string }>
): TocEntry[] {
  const result: TocEntry[] = [];
  const stack: TocEntry[] = [];

  for (const entry of entries) {
    const tocEntry: TocEntry = {
      depth: entry.depth,
      text: entry.text,
      slug: entry.slug,
      children: [],
    };

    while (stack.length > 0 && stack[stack.length - 1].depth >= entry.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      result.push(tocEntry);
    } else {
      stack[stack.length - 1].children.push(tocEntry);
    }

    stack.push(tocEntry);
  }

  return result;
}

/**
 * Generates the JavaScript module code.
 */
function generateModuleCode(
  html: string,
  frontmatter: Record<string, unknown>,
  toc: TocEntry[],
  filePath: string
): string {
  const htmlJson = JSON.stringify(html);
  const frontmatterJson = JSON.stringify(frontmatter);
  const tocJson = JSON.stringify(toc);

  return `
// Generated by unplugin-ox-content
// Source: ${filePath}

export const html = ${htmlJson};
export const frontmatter = ${frontmatterJson};
export const toc = ${tocJson};

export default {
  html,
  frontmatter,
  toc,
};
`;
}
