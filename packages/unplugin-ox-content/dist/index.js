// src/index.ts
import { createUnplugin } from "unplugin";
import { createFilter } from "@rollup/pluginutils";

// src/transform.ts
var napiBindings = null;
async function loadNapiBindings() {
  if (napiBindings) {
    return napiBindings;
  }
  try {
    const mod = await import("@ox-content/napi");
    napiBindings = mod;
    return mod;
  } catch (error) {
    throw new Error(
      `[unplugin-ox-content] @ox-content/napi is required but not available. Please build the NAPI bindings first.
Original error: ${error}`
    );
  }
}
async function transformMarkdown(source, filePath, options) {
  const napi = await loadNapiBindings();
  const result = napi.transform(source, {
    gfm: options.gfm,
    footnotes: options.footnotes,
    taskLists: options.taskLists,
    tables: options.tables,
    strikethrough: options.strikethrough,
    tocMaxDepth: options.tocMaxDepth
  });
  if (result.errors.length > 0) {
    console.warn("[ox-content] Parse warnings:", result.errors);
  }
  let frontmatter = {};
  try {
    frontmatter = JSON.parse(result.frontmatter);
  } catch {
  }
  const toc = buildTocTree(result.toc);
  const code = generateModuleCode(result.html, frontmatter, toc, filePath);
  return {
    code,
    html: result.html,
    frontmatter,
    toc
  };
}
function buildTocTree(entries) {
  const result = [];
  const stack = [];
  for (const entry of entries) {
    const tocEntry = {
      depth: entry.depth,
      text: entry.text,
      slug: entry.slug,
      children: []
    };
    while (stack.length > 0 && stack[stack.length - 1].depth >= entry.depth) {
      stack.pop();
    }
    if (stack.length === 0) {
      result.push(tocEntry);
    } else {
      stack[stack.length - 1].children.push(tocEntry);
    }
    stack.push(tocEntry);
  }
  return result;
}
function generateModuleCode(html, frontmatter, toc, filePath) {
  const htmlJson = JSON.stringify(html);
  const frontmatterJson = JSON.stringify(frontmatter);
  const tocJson = JSON.stringify(toc);
  return `
// Generated by unplugin-ox-content
// Source: ${filePath}

export const html = ${htmlJson};
export const frontmatter = ${frontmatterJson};
export const toc = ${tocJson};

export default {
  html,
  frontmatter,
  toc,
};
`;
}

// src/index.ts
function resolveOptions(options) {
  const extensions = options.extensions ?? [".md", ".markdown"];
  return {
    srcDir: options.srcDir ?? "docs",
    gfm: options.gfm ?? true,
    footnotes: options.footnotes ?? true,
    tables: options.tables ?? true,
    taskLists: options.taskLists ?? true,
    strikethrough: options.strikethrough ?? true,
    highlight: options.highlight ?? false,
    highlightTheme: options.highlightTheme ?? "github-dark",
    mermaid: options.mermaid ?? false,
    frontmatter: options.frontmatter ?? true,
    toc: options.toc ?? true,
    tocMaxDepth: options.tocMaxDepth ?? 3,
    extensions,
    include: Array.isArray(options.include) ? options.include : options.include ? [options.include] : [],
    exclude: Array.isArray(options.exclude) ? options.exclude : options.exclude ? [options.exclude] : []
  };
}
function isMarkdownFile(id, options) {
  return options.extensions.some((ext) => id.endsWith(ext));
}
var unpluginFactory = (rawOptions = {}) => {
  const options = resolveOptions(rawOptions);
  const filter = createFilter(
    options.include.length > 0 ? options.include : void 0,
    options.exclude.length > 0 ? options.exclude : void 0
  );
  return {
    name: "unplugin-ox-content",
    resolveId(id) {
      if (id.startsWith("virtual:ox-content/")) {
        return "\0" + id;
      }
      return null;
    },
    loadInclude(id) {
      return id.startsWith("\0virtual:ox-content/");
    },
    load(id) {
      if (id.startsWith("\0virtual:ox-content/")) {
        const path = id.slice("\0virtual:ox-content/".length);
        if (path === "config") {
          return `export default ${JSON.stringify(options)};`;
        }
        if (path === "runtime") {
          return `
            export function useMarkdown() {
              return {
                render: (content) => content,
              };
            }
          `;
        }
        return "export default {};";
      }
      return null;
    },
    transformInclude(id) {
      return isMarkdownFile(id, options) && filter(id);
    },
    async transform(code, id) {
      if (!isMarkdownFile(id, options)) {
        return null;
      }
      if (!filter(id)) {
        return null;
      }
      const result = await transformMarkdown(code, id, options);
      return {
        code: result.code,
        map: null
      };
    }
  };
};
var unplugin = /* @__PURE__ */ createUnplugin(unpluginFactory);
var index_default = unplugin;
export {
  index_default as default,
  transformMarkdown,
  unplugin
};
