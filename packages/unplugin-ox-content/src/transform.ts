/**
 * Markdown transformation logic for unplugin-ox-content.
 *
 * Uses the Rust-based @ox-content/napi for high-performance processing.
 */

import type { ResolvedOptions, TransformResult, TocEntry } from './types';

// NAPI bindings interface
interface NapiTransformResult {
  html: string;
  frontmatter: string;
  toc: Array<{ depth: number; text: string; slug: string }>;
  errors: string[];
}

interface NapiBindings {
  transform: (
    source: string,
    options?: {
      gfm?: boolean;
      footnotes?: boolean;
      taskLists?: boolean;
      tables?: boolean;
      strikethrough?: boolean;
      autolinks?: boolean;
      tocMaxDepth?: number;
    }
  ) => NapiTransformResult;
}

// Cached NAPI bindings
let napiBindings: NapiBindings | null = null;

/**
 * Load NAPI bindings.
 * Throws if NAPI is not available.
 */
async function loadNapiBindings(): Promise<NapiBindings> {
  if (napiBindings) {
    return napiBindings;
  }

  try {
    const mod = await import('@ox-content/napi');
    napiBindings = mod;
    return mod;
  } catch (error) {
    throw new Error(
      '[unplugin-ox-content] @ox-content/napi is required but not available. ' +
        'Please build the NAPI bindings first.\n' +
        `Original error: ${error}`
    );
  }
}

/**
 * Transforms Markdown content into a JavaScript module.
 *
 * Uses the Rust-based NAPI bindings for:
 * - Frontmatter parsing
 * - Table of contents generation
 * - HTML rendering
 */
export async function transformMarkdown(
  source: string,
  filePath: string,
  options: ResolvedOptions
): Promise<TransformResult> {
  const napi = await loadNapiBindings();

  const result = napi.transform(source, {
    gfm: options.gfm,
    footnotes: options.footnotes,
    taskLists: options.taskLists,
    tables: options.tables,
    strikethrough: options.strikethrough,
    tocMaxDepth: options.tocMaxDepth,
  });

  if (result.errors.length > 0) {
    console.warn('[ox-content] Parse warnings:', result.errors);
  }

  // Parse frontmatter JSON
  let frontmatter: Record<string, unknown> = {};
  try {
    frontmatter = JSON.parse(result.frontmatter);
  } catch {
    // Ignore parse errors, use empty object
  }

  // Convert TOC to nested structure
  const toc = buildTocTree(result.toc);

  // Generate JavaScript module code
  const code = generateModuleCode(result.html, frontmatter, toc, filePath);

  return {
    code,
    html: result.html,
    frontmatter,
    toc,
  };
}

/**
 * Builds nested TOC tree from flat list.
 */
function buildTocTree(
  entries: Array<{ depth: number; text: string; slug: string }>
): TocEntry[] {
  const result: TocEntry[] = [];
  const stack: TocEntry[] = [];

  for (const entry of entries) {
    const tocEntry: TocEntry = {
      depth: entry.depth,
      text: entry.text,
      slug: entry.slug,
      children: [],
    };

    // Pop stack until we find a parent with smaller depth
    while (stack.length > 0 && stack[stack.length - 1].depth >= entry.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      result.push(tocEntry);
    } else {
      stack[stack.length - 1].children.push(tocEntry);
    }

    stack.push(tocEntry);
  }

  return result;
}

/**
 * Generates the JavaScript module code.
 */
function generateModuleCode(
  html: string,
  frontmatter: Record<string, unknown>,
  toc: TocEntry[],
  filePath: string
): string {
  const htmlJson = JSON.stringify(html);
  const frontmatterJson = JSON.stringify(frontmatter);
  const tocJson = JSON.stringify(toc);

  return `
// Generated by unplugin-ox-content
// Source: ${filePath}

export const html = ${htmlJson};
export const frontmatter = ${frontmatterJson};
export const toc = ${tocJson};

export default {
  html,
  frontmatter,
  toc,
};
`;
}
