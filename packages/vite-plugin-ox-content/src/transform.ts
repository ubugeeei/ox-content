/**
 * Markdown transformation logic.
 *
 * Transforms Markdown source into JavaScript modules
 * that can be imported by the application.
 */

import type { ResolvedOptions, TransformResult, TocEntry } from './types';
import { highlightCode } from './highlight';
import { transformMermaid } from './mermaid';

// NAPI bindings interface
interface NapiBindings {
  parseAndRender: (source: string, options?: { gfm?: boolean }) => { html: string; errors: string[] };
  transform: (source: string, options?: JsTransformOptions) => {
    html: string;
    frontmatter: string;
    toc: { depth: number; text: string; slug: string }[];
    errors: string[];
  };
}

interface JsTransformOptions {
  gfm?: boolean;
  footnotes?: boolean;
  taskLists?: boolean;
  tables?: boolean;
  strikethrough?: boolean;
  autolinks?: boolean;
  tocMaxDepth?: number;
}

// Cached NAPI bindings
let napiBindings: NapiBindings | null | undefined;
let napiLoadAttempted = false;

/**
 * Lazily load NAPI bindings.
 */
async function loadNapiBindings(): Promise<NapiBindings | null> {
  if (napiLoadAttempted) {
    return napiBindings ?? null;
  }
  napiLoadAttempted = true;

  try {
    // Dynamic import to handle cases where NAPI isn't built
    const mod = await import('@ox-content/napi');
    napiBindings = mod;
    return mod;
  } catch {
    // NAPI not available, will use fallback
    napiBindings = null;
    return null;
  }
}

/**
 * Transforms Markdown content into a JavaScript module.
 *
 * The generated module exports:
 * - `html`: The rendered HTML string
 * - `frontmatter`: Parsed YAML frontmatter object
 * - `toc`: Table of contents array
 * - `render`: Function to render with custom options
 */
export async function transformMarkdown(
  source: string,
  filePath: string,
  options: ResolvedOptions
): Promise<TransformResult> {
  const napi = await loadNapiBindings();

  if (!napi) {
    throw new Error('[ox-content] NAPI bindings not available. Please ensure @ox-content/napi is built.');
  }

  // Use Rust-based transformation
  const result = napi.transform(source, {
    gfm: options.gfm,
    footnotes: options.footnotes,
    taskLists: options.taskLists,
    tables: options.tables,
    strikethrough: options.strikethrough,
    tocMaxDepth: options.tocMaxDepth,
  });

  if (result.errors.length > 0) {
    console.warn('[ox-content] Transform warnings:', result.errors);
  }

  let html = result.html;
  let frontmatter: Record<string, unknown>;

  try {
    frontmatter = JSON.parse(result.frontmatter);
  } catch {
    frontmatter = {};
  }

  // Convert flat TOC from Rust to nested TOC
  const flatToc: TocEntry[] = result.toc.map(item => ({
    ...item,
    children: [],
  }));
  const toc = options.toc ? buildTocTree(flatToc) : [];

  // Apply syntax highlighting if enabled
  if (options.highlight) {
    html = await highlightCode(html, options.highlightTheme);
  }

  // Transform mermaid diagrams if enabled
  if (options.mermaid) {
    html = await transformMermaid(html);
  }

  // Generate JavaScript module code
  const code = generateModuleCode(html, frontmatter, toc, filePath, options);

  return {
    code,
    html,
    frontmatter,
    toc,
  };
}

/**
 * Builds nested TOC tree from flat list.
 */
function buildTocTree(entries: TocEntry[]): TocEntry[] {
  const root: TocEntry[] = [];
  const stack: TocEntry[] = [];

  for (const entry of entries) {
    // Pop stack until we find a parent with smaller depth
    while (stack.length > 0 && stack[stack.length - 1].depth >= entry.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      root.push(entry);
    } else {
      stack[stack.length - 1].children.push(entry);
    }

    stack.push(entry);
  }

  return root;
}

/**
 * Generates the JavaScript module code.
 */
function generateModuleCode(
  html: string,
  frontmatter: Record<string, unknown>,
  toc: TocEntry[],
  filePath: string,
  _options: ResolvedOptions
): string {
  const htmlJson = JSON.stringify(html);
  const frontmatterJson = JSON.stringify(frontmatter);
  const tocJson = JSON.stringify(toc);

  return `
// Generated by vite-plugin-ox-content
// Source: ${filePath}

/**
 * Rendered HTML content.
 */
export const html = ${htmlJson};

/**
 * Parsed frontmatter.
 */
export const frontmatter = ${frontmatterJson};

/**
 * Table of contents.
 */
export const toc = ${tocJson};

/**
 * Default export with all data.
 */
export default {
  html,
  frontmatter,
  toc,
};

// HMR support
if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    if (newModule) {
      // Trigger re-render with new content
      import.meta.hot.invalidate();
    }
  });
}
`;
}

/**
 * Extracts imports from Markdown content.
 *
 * Supports importing components for interactive islands.
 */
export function extractImports(content: string): string[] {
  const importRegex = /^import\s+.+\s+from\s+['"](.+)['"]/gm;
  const imports: string[] = [];
  let match;

  while ((match = importRegex.exec(content)) !== null) {
    imports.push(match[1]);
  }

  return imports;
}
