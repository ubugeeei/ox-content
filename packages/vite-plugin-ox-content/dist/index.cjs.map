{"version":3,"sources":["../src/index.ts","../src/environment.ts","../src/highlight.ts","../src/mermaid.ts","../src/transform.ts","../src/docs.ts"],"sourcesContent":["/**\n * Vite Plugin for Ox Content\n *\n * Uses Vite's Environment API for SSG-focused Markdown processing.\n * Provides separate environments for client and server rendering.\n */\n\nimport * as path from 'path';\nimport type { Plugin, ViteDevServer, ResolvedConfig } from 'vite';\nimport { createMarkdownEnvironment } from './environment';\nimport { transformMarkdown } from './transform';\nimport { extractDocs, generateMarkdown, writeDocs, resolveDocsOptions } from './docs';\nimport type { OxContentOptions, ResolvedOptions } from './types';\n\nexport type { OxContentOptions } from './types';\nexport type {\n  DocsOptions,\n  ResolvedDocsOptions,\n  DocEntry,\n  ParamDoc,\n  ReturnDoc,\n  ExtractedDocs,\n} from './types';\n\n/**\n * Creates the Ox Content Vite plugin.\n *\n * @example\n * ```ts\n * // vite.config.ts\n * import { defineConfig } from 'vite';\n * import { oxContent } from 'vite-plugin-ox-content';\n *\n * export default defineConfig({\n *   plugins: [\n *     oxContent({\n *       srcDir: 'docs',\n *       gfm: true,\n *     }),\n *   ],\n * });\n * ```\n */\nexport function oxContent(options: OxContentOptions = {}): Plugin[] {\n  const resolvedOptions = resolveOptions(options);\n  let config: ResolvedConfig;\n  let _server: ViteDevServer | undefined;\n\n  const mainPlugin: Plugin = {\n    name: 'ox-content',\n\n    configResolved(resolvedConfig) {\n      config = resolvedConfig;\n    },\n\n    configureServer(devServer) {\n      _server = devServer;\n\n      // Add middleware for serving Markdown files\n      devServer.middlewares.use(async (req, res, next) => {\n        const url = req.url;\n        if (!url || !url.endsWith('.md')) {\n          return next();\n        }\n\n        // Let Vite handle the transformation\n        next();\n      });\n    },\n\n    resolveId(id) {\n      // Handle virtual modules for Markdown imports\n      if (id.startsWith('virtual:ox-content/')) {\n        return '\\0' + id;\n      }\n\n      // Resolve .md files\n      if (id.endsWith('.md')) {\n        return id;\n      }\n\n      return null;\n    },\n\n    async load(id) {\n      // Handle virtual modules\n      if (id.startsWith('\\0virtual:ox-content/')) {\n        const path = id.slice('\\0virtual:ox-content/'.length);\n        return generateVirtualModule(path, resolvedOptions);\n      }\n\n      return null;\n    },\n\n    async transform(code, id) {\n      if (!id.endsWith('.md')) {\n        return null;\n      }\n\n      // Transform Markdown to JavaScript module\n      const result = await transformMarkdown(code, id, resolvedOptions);\n\n      return {\n        code: result.code,\n        map: null,\n      };\n    },\n\n    // Hot Module Replacement support\n    async handleHotUpdate({ file, server }) {\n      if (file.endsWith('.md')) {\n        // Notify client about the update\n        server.ws.send({\n          type: 'custom',\n          event: 'ox-content:update',\n          data: { file },\n        });\n\n        // Return empty array to prevent default HMR\n        // We handle it ourselves\n        const modules = server.moduleGraph.getModulesByFile(file);\n        return modules ? Array.from(modules) : [];\n      }\n    },\n  };\n\n  // Environment API plugin for SSG\n  const environmentPlugin: Plugin = {\n    name: 'ox-content:environment',\n\n    config() {\n      return {\n        environments: {\n          // Markdown processing environment\n          markdown: createMarkdownEnvironment(resolvedOptions),\n        },\n      };\n    },\n  };\n\n  // Docs generation plugin (builtin, opt-out)\n  const docsPlugin: Plugin = {\n    name: 'ox-content:docs',\n\n    async buildStart() {\n      const docsOptions = resolvedOptions.docs;\n      if (!docsOptions || !docsOptions.enabled) {\n        return;\n      }\n\n      // Generate docs at build start\n      const root = config?.root || process.cwd();\n      const srcDirs = docsOptions.src.map((src) => path.resolve(root, src));\n      const outDir = path.resolve(root, docsOptions.out);\n\n      try {\n        const extracted = await extractDocs(srcDirs, docsOptions);\n\n        if (extracted.length > 0) {\n          const generated = generateMarkdown(extracted, docsOptions);\n          await writeDocs(generated, outDir);\n\n          console.log(\n            `[ox-content] Generated ${Object.keys(generated).length} documentation files to ${docsOptions.out}`\n          );\n        }\n      } catch (err) {\n        console.warn('[ox-content] Failed to generate documentation:', err);\n      }\n    },\n\n    configureServer(devServer) {\n      const docsOptions = resolvedOptions.docs;\n      if (!docsOptions || !docsOptions.enabled) {\n        return;\n      }\n\n      // Watch source directories for changes\n      const root = config?.root || process.cwd();\n      const srcDirs = docsOptions.src.map((src) => path.resolve(root, src));\n\n      for (const srcDir of srcDirs) {\n        devServer.watcher.add(srcDir);\n      }\n\n      // Regenerate docs on file changes\n      devServer.watcher.on('change', async (file) => {\n        const isSourceFile = srcDirs.some(\n          (srcDir) =>\n            file.startsWith(srcDir) &&\n            (file.endsWith('.ts') || file.endsWith('.tsx'))\n        );\n\n        if (isSourceFile) {\n          const outDir = path.resolve(root, docsOptions.out);\n\n          try {\n            const extracted = await extractDocs(srcDirs, docsOptions);\n            if (extracted.length > 0) {\n              const generated = generateMarkdown(extracted, docsOptions);\n              await writeDocs(generated, outDir);\n            }\n          } catch {\n            // Ignore errors during dev\n          }\n        }\n      });\n    },\n  };\n\n  return [mainPlugin, environmentPlugin, docsPlugin];\n}\n\n/**\n * Resolves plugin options with defaults.\n */\nfunction resolveOptions(options: OxContentOptions): ResolvedOptions {\n  return {\n    srcDir: options.srcDir ?? 'docs',\n    outDir: options.outDir ?? 'dist',\n    base: options.base ?? '/',\n    gfm: options.gfm ?? true,\n    footnotes: options.footnotes ?? true,\n    tables: options.tables ?? true,\n    taskLists: options.taskLists ?? true,\n    strikethrough: options.strikethrough ?? true,\n    highlight: options.highlight ?? false,\n    highlightTheme: options.highlightTheme ?? 'github-dark',\n    mermaid: options.mermaid ?? false,\n    frontmatter: options.frontmatter ?? true,\n    toc: options.toc ?? true,\n    tocMaxDepth: options.tocMaxDepth ?? 3,\n    ogImage: options.ogImage ?? false,\n    ogImageOptions: options.ogImageOptions ?? {},\n    transformers: options.transformers ?? [],\n    docs: resolveDocsOptions(options.docs),\n  };\n}\n\n/**\n * Generates virtual module content.\n */\nfunction generateVirtualModule(\n  path: string,\n  options: ResolvedOptions\n): string {\n  if (path === 'config') {\n    return `export default ${JSON.stringify(options)};`;\n  }\n\n  if (path === 'runtime') {\n    return `\n      export function useMarkdown() {\n        return {\n          render: (content) => {\n            // Client-side rendering if needed\n            return content;\n          },\n        };\n      }\n    `;\n  }\n\n  return 'export default {};';\n}\n\n// Re-export types and utilities\nexport { createMarkdownEnvironment } from './environment';\nexport { transformMarkdown } from './transform';\nexport { extractDocs, generateMarkdown, writeDocs, resolveDocsOptions } from './docs';\nexport * from './types';\n","/**\n * Vite Environment API integration for Ox Content.\n *\n * Creates a dedicated environment for Markdown processing,\n * enabling SSG-style rendering with separate client/server contexts.\n */\n\nimport type { EnvironmentOptions } from 'vite';\nimport type { ResolvedOptions } from './types';\n\n/**\n * Creates the Markdown processing environment configuration.\n *\n * This environment is used for:\n * - Server-side rendering of Markdown files\n * - Static site generation\n * - Pre-rendering at build time\n *\n * @example\n * ```ts\n * // In your vite.config.ts\n * export default defineConfig({\n *   environments: {\n *     markdown: createMarkdownEnvironment({\n *       srcDir: 'docs',\n *       gfm: true,\n *     }),\n *   },\n * });\n * ```\n */\nexport function createMarkdownEnvironment(\n  options: ResolvedOptions\n): EnvironmentOptions {\n  return {\n    // Consumer type for this environment\n    consumer: 'server',\n\n    // Build configuration\n    build: {\n      // Output to a separate directory\n      outDir: `${options.outDir}/.markdown`,\n\n      // Emit assets for SSG\n      emitAssets: true,\n\n      // Create manifest for asset tracking\n      manifest: true,\n\n      // SSR-like externalization\n      rollupOptions: {\n        external: [\n          // Externalize Node.js built-ins\n          /^node:/,\n          // Externalize native modules\n          /\\.node$/,\n        ],\n      },\n    },\n\n    // Resolve configuration\n    resolve: {\n      // Handle .md files\n      extensions: ['.md', '.markdown'],\n\n      // Conditions for module resolution\n      conditions: ['markdown', 'node', 'import'],\n\n      // Don't dedupe - each environment gets its own modules\n      dedupe: [],\n    },\n\n    // Optimize dependencies\n    optimizeDeps: {\n      // Include ox-content dependencies\n      include: [],\n      // Exclude native modules\n      exclude: ['@ox-content/napi'],\n    },\n  };\n}\n\n/**\n * Environment-specific module transformer.\n *\n * This is called during the transform phase to process\n * Markdown files within the environment context.\n */\nexport interface EnvironmentTransformContext {\n  /**\n   * Current environment name.\n   */\n  environment: string;\n\n  /**\n   * Whether we're in development mode.\n   */\n  isDev: boolean;\n\n  /**\n   * Whether this is a server-side render.\n   */\n  isSSR: boolean;\n\n  /**\n   * The resolved Vite config.\n   */\n  config: unknown;\n}\n\n/**\n * Creates environment-aware transform options.\n */\nexport function createTransformOptions(\n  ctx: EnvironmentTransformContext,\n  options: ResolvedOptions\n): ResolvedOptions {\n  return {\n    ...options,\n    // Adjust options based on environment\n    highlight: ctx.isSSR ? options.highlight : false,\n    ogImage: ctx.isSSR ? options.ogImage : false,\n  };\n}\n\n/**\n * Runs pre-render for SSG.\n *\n * This function is called during build to pre-render all Markdown files.\n */\nexport async function prerender(\n  files: string[],\n  _options: ResolvedOptions\n): Promise<Map<string, string>> {\n  const results = new Map<string, string>();\n\n  for (const file of files) {\n    // In production, this would use the Ox Content parser\n    // For now, we just mark the file as needing processing\n    results.set(file, `/* Pre-rendered: ${file} */`);\n  }\n\n  return results;\n}\n\n/**\n * Environment plugin factory.\n *\n * Creates plugins specific to the Markdown environment.\n */\nexport function createEnvironmentPlugins(_options: ResolvedOptions) {\n  return [\n    {\n      name: 'ox-content:markdown-env',\n\n      // Only apply to markdown environment\n      applyToEnvironment(name: string) {\n        return name === 'markdown';\n      },\n\n      // Transform within the environment\n      transform(code: string, id: string) {\n        if (!id.endsWith('.md')) {\n          return null;\n        }\n\n        // Environment-specific transformation\n        return {\n          code: `\n            // Transformed in markdown environment\n            ${code}\n          `,\n        };\n      },\n    },\n  ];\n}\n","/**\n * Syntax highlighting with Shiki via rehype.\n */\n\nimport { unified } from 'unified';\nimport rehypeParse from 'rehype-parse';\nimport rehypeStringify from 'rehype-stringify';\nimport type { Root, Element } from 'hast';\nimport { createHighlighter, type Highlighter, type BundledTheme } from 'shiki';\n\n// Cached highlighter instance\nlet highlighterPromise: Promise<Highlighter> | null = null;\n\n/**\n * Get or create the Shiki highlighter.\n */\nasync function getHighlighter(theme: string): Promise<Highlighter> {\n  if (!highlighterPromise) {\n    highlighterPromise = createHighlighter({\n      themes: [theme as BundledTheme],\n      langs: [\n        'javascript',\n        'typescript',\n        'jsx',\n        'tsx',\n        'vue',\n        'svelte',\n        'html',\n        'css',\n        'scss',\n        'json',\n        'yaml',\n        'markdown',\n        'bash',\n        'shell',\n        'rust',\n        'python',\n        'go',\n        'java',\n        'c',\n        'cpp',\n        'sql',\n        'graphql',\n        'diff',\n        'toml',\n      ],\n    });\n  }\n  return highlighterPromise;\n}\n\n/**\n * Rehype plugin for syntax highlighting with Shiki.\n */\nfunction rehypeShikiHighlight(options: { theme: string }) {\n  const { theme } = options;\n\n  return async (tree: Root) => {\n    const highlighter = await getHighlighter(theme);\n\n    // Find all pre > code elements\n    const visit = async (node: Root | Element) => {\n      if ('children' in node) {\n        for (let i = 0; i < node.children.length; i++) {\n          const child = node.children[i];\n\n          if (child.type === 'element' && child.tagName === 'pre') {\n            const codeElement = child.children.find(\n              (c): c is Element => c.type === 'element' && c.tagName === 'code'\n            );\n\n            if (codeElement) {\n              // Extract language from class\n              const className = codeElement.properties?.className;\n              let lang = 'text';\n\n              if (Array.isArray(className)) {\n                const langClass = className.find(\n                  (c) => typeof c === 'string' && c.startsWith('language-')\n                );\n                if (langClass && typeof langClass === 'string') {\n                  lang = langClass.replace('language-', '');\n                }\n              }\n\n              // Get code text\n              const codeText = getTextContent(codeElement);\n\n              // Highlight with Shiki\n              try {\n                const highlighted = highlighter.codeToHtml(codeText, {\n                  lang: lang as any,\n                  theme: theme as BundledTheme,\n                });\n\n                // Parse the highlighted HTML and replace the pre element\n                const parsed = unified()\n                  .use(rehypeParse, { fragment: true })\n                  .parse(highlighted);\n\n                // Replace the pre element with the highlighted one\n                if (parsed.children[0]) {\n                  node.children[i] = parsed.children[0] as Element;\n                }\n              } catch {\n                // If highlighting fails, keep the original\n              }\n            }\n          } else if (child.type === 'element') {\n            await visit(child);\n          }\n        }\n      }\n    };\n\n    await visit(tree);\n  };\n}\n\n/**\n * Extract text content from a hast node.\n */\nfunction getTextContent(node: Element | Root): string {\n  let text = '';\n\n  if ('children' in node) {\n    for (const child of node.children) {\n      if (child.type === 'text') {\n        text += child.value;\n      } else if (child.type === 'element') {\n        text += getTextContent(child);\n      }\n    }\n  }\n\n  return text;\n}\n\n/**\n * Apply syntax highlighting to HTML using Shiki.\n */\nexport async function highlightCode(\n  html: string,\n  theme: string = 'github-dark'\n): Promise<string> {\n  const result = await unified()\n    .use(rehypeParse, { fragment: true })\n    .use(rehypeShikiHighlight, { theme })\n    .use(rehypeStringify)\n    .process(html);\n\n  return String(result);\n}\n","/**\n * Mermaid diagram support.\n *\n * Transforms mermaid code blocks into SVG diagrams.\n * Uses client-side rendering with a wrapper element.\n */\n\nimport { unified } from 'unified';\nimport rehypeParse from 'rehype-parse';\nimport rehypeStringify from 'rehype-stringify';\nimport type { Root, Element } from 'hast';\n\n/**\n * Extract text content from a hast node.\n */\nfunction getTextContent(node: Element | Root): string {\n  let text = '';\n\n  if ('children' in node) {\n    for (const child of node.children) {\n      if (child.type === 'text') {\n        text += child.value;\n      } else if (child.type === 'element') {\n        text += getTextContent(child);\n      }\n    }\n  }\n\n  return text;\n}\n\n/**\n * Rehype plugin to transform mermaid code blocks.\n *\n * Replaces ```mermaid blocks with a wrapper element\n * that can be rendered client-side.\n */\nfunction rehypeMermaid() {\n  return (tree: Root) => {\n    const visit = (node: Root | Element) => {\n      if ('children' in node) {\n        for (let i = 0; i < node.children.length; i++) {\n          const child = node.children[i];\n\n          if (child.type === 'element' && child.tagName === 'pre') {\n            const codeElement = child.children.find(\n              (c): c is Element => c.type === 'element' && c.tagName === 'code'\n            );\n\n            if (codeElement) {\n              // Check if this is a mermaid code block\n              const className = codeElement.properties?.className;\n              let isMermaid = false;\n\n              if (Array.isArray(className)) {\n                isMermaid = className.some(\n                  (c) => typeof c === 'string' && c.includes('mermaid')\n                );\n              }\n\n              if (isMermaid) {\n                const mermaidCode = getTextContent(codeElement);\n\n                // Replace with mermaid wrapper\n                const wrapper: Element = {\n                  type: 'element',\n                  tagName: 'div',\n                  properties: {\n                    className: ['ox-mermaid'],\n                    'data-mermaid': mermaidCode,\n                  },\n                  children: [\n                    {\n                      type: 'element',\n                      tagName: 'pre',\n                      properties: {\n                        className: ['ox-mermaid-source'],\n                      },\n                      children: [\n                        {\n                          type: 'text',\n                          value: mermaidCode,\n                        },\n                      ],\n                    },\n                  ],\n                };\n\n                node.children[i] = wrapper;\n              }\n            }\n          } else if (child.type === 'element') {\n            visit(child);\n          }\n        }\n      }\n    };\n\n    visit(tree);\n  };\n}\n\n/**\n * Transform mermaid code blocks in HTML.\n *\n * Creates wrapper elements that can be rendered client-side\n * by the mermaid runtime.\n */\nexport async function transformMermaid(html: string): Promise<string> {\n  const result = await unified()\n    .use(rehypeParse, { fragment: true })\n    .use(rehypeMermaid)\n    .use(rehypeStringify)\n    .process(html);\n\n  return String(result);\n}\n\n/**\n * Client-side mermaid initialization script.\n *\n * This script should be included in the page to render\n * mermaid diagrams.\n */\nexport const mermaidClientScript = `\n<script type=\"module\">\n  import mermaid from 'https://esm.sh/mermaid@11/dist/mermaid.esm.min.mjs';\n\n  mermaid.initialize({\n    startOnLoad: false,\n    theme: 'dark',\n    themeVariables: {\n      primaryColor: '#bd34fe',\n      primaryTextColor: '#fff',\n      primaryBorderColor: '#7c3aed',\n      lineColor: '#41d1ff',\n      secondaryColor: '#1a1a2e',\n      tertiaryColor: '#161618',\n    },\n  });\n\n  async function renderMermaidDiagrams() {\n    const elements = document.querySelectorAll('.ox-mermaid');\n\n    for (const el of elements) {\n      const code = el.dataset.mermaid;\n      if (!code) continue;\n\n      try {\n        const id = 'mermaid-' + Math.random().toString(36).slice(2, 9);\n        const { svg } = await mermaid.render(id, code);\n\n        // Replace content with rendered SVG\n        el.innerHTML = svg;\n        el.classList.add('ox-mermaid-rendered');\n      } catch (err) {\n        console.error('Mermaid render error:', err);\n        el.classList.add('ox-mermaid-error');\n      }\n    }\n  }\n\n  // Render on load and on HMR updates\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', renderMermaidDiagrams);\n  } else {\n    renderMermaidDiagrams();\n  }\n\n  // Re-render on content updates (for SPA navigation)\n  if (import.meta.hot) {\n    import.meta.hot.on('ox-content:update', renderMermaidDiagrams);\n  }\n</script>\n`;\n\n/**\n * CSS styles for mermaid diagrams.\n */\nexport const mermaidStyles = `\n<style>\n  .ox-mermaid {\n    margin: 1.5rem 0;\n    padding: 1rem;\n    background: var(--code-bg, #161618);\n    border-radius: 8px;\n    border: 1px solid var(--border-color, #2e2e32);\n    overflow-x: auto;\n  }\n\n  .ox-mermaid-source {\n    display: none;\n  }\n\n  .ox-mermaid-rendered .ox-mermaid-source {\n    display: none;\n  }\n\n  .ox-mermaid svg {\n    max-width: 100%;\n    height: auto;\n  }\n\n  .ox-mermaid-error {\n    color: #f87171;\n    padding: 1rem;\n  }\n\n  .ox-mermaid-error .ox-mermaid-source {\n    display: block;\n  }\n</style>\n`;\n","/**\n * Markdown transformation logic.\n *\n * Transforms Markdown source into JavaScript modules\n * that can be imported by the application.\n */\n\nimport type { ResolvedOptions, TransformResult, TocEntry } from './types';\nimport { highlightCode } from './highlight';\nimport { transformMermaid, mermaidClientScript, mermaidStyles } from './mermaid';\n\n// NAPI bindings interface\ninterface NapiBindings {\n  parseAndRender: (source: string, options?: { gfm?: boolean }) => { html: string; errors: string[] };\n}\n\n// Cached NAPI bindings\nlet napiBindings: NapiBindings | null | undefined;\nlet napiLoadAttempted = false;\n\n/**\n * Lazily load NAPI bindings.\n */\nasync function loadNapiBindings(): Promise<NapiBindings | null> {\n  if (napiLoadAttempted) {\n    return napiBindings ?? null;\n  }\n  napiLoadAttempted = true;\n\n  try {\n    // Dynamic import to handle cases where NAPI isn't built\n    const mod = await import('@ox-content/napi');\n    napiBindings = mod;\n    return mod;\n  } catch {\n    // NAPI not available, will use fallback\n    napiBindings = null;\n    return null;\n  }\n}\n\n/**\n * Transforms Markdown content into a JavaScript module.\n *\n * The generated module exports:\n * - `html`: The rendered HTML string\n * - `frontmatter`: Parsed YAML frontmatter object\n * - `toc`: Table of contents array\n * - `render`: Function to render with custom options\n */\nexport async function transformMarkdown(\n  source: string,\n  filePath: string,\n  options: ResolvedOptions\n): Promise<TransformResult> {\n  // Parse frontmatter\n  const { content, frontmatter } = parseFrontmatter(source);\n\n  // Generate table of contents\n  const toc = options.toc ? generateToc(content, options.tocMaxDepth) : [];\n\n  // Render HTML using NAPI bindings (Rust parser) if available\n  let html = await renderToHtml(content, options);\n\n  // Apply syntax highlighting if enabled\n  if (options.highlight) {\n    html = await highlightCode(html, options.highlightTheme);\n  }\n\n  // Transform mermaid diagrams if enabled\n  if (options.mermaid) {\n    html = await transformMermaid(html);\n  }\n\n  // Generate JavaScript module code\n  const code = generateModuleCode(html, frontmatter, toc, filePath, options);\n\n  return {\n    code,\n    html,\n    frontmatter,\n    toc,\n  };\n}\n\n/**\n * Parses YAML frontmatter from Markdown content.\n */\nfunction parseFrontmatter(source: string): {\n  content: string;\n  frontmatter: Record<string, unknown>;\n} {\n  const frontmatterRegex = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---\\r?\\n/;\n  const match = source.match(frontmatterRegex);\n\n  if (!match) {\n    return { content: source, frontmatter: {} };\n  }\n\n  const frontmatterStr = match[1];\n  const content = source.slice(match[0].length);\n\n  // Simple YAML parsing (in production, use a proper YAML parser)\n  const frontmatter: Record<string, unknown> = {};\n  const lines = frontmatterStr.split('\\n');\n\n  for (const line of lines) {\n    const colonIndex = line.indexOf(':');\n    if (colonIndex > 0) {\n      const key = line.slice(0, colonIndex).trim();\n      let value: unknown = line.slice(colonIndex + 1).trim();\n\n      // Parse basic types\n      if (value === 'true') value = true;\n      else if (value === 'false') value = false;\n      else if (!isNaN(Number(value)) && value !== '') value = Number(value);\n      else if (typeof value === 'string' && value.startsWith('\"') && value.endsWith('\"')) {\n        value = value.slice(1, -1);\n      }\n\n      frontmatter[key] = value;\n    }\n  }\n\n  return { content, frontmatter };\n}\n\n/**\n * Generates table of contents from Markdown content.\n */\nfunction generateToc(content: string, maxDepth: number): TocEntry[] {\n  const headingRegex = /^(#{1,6})\\s+(.+)$/gm;\n  const entries: TocEntry[] = [];\n  let match;\n\n  while ((match = headingRegex.exec(content)) !== null) {\n    const depth = match[1].length;\n    if (depth > maxDepth) continue;\n\n    const text = match[2].trim();\n    const slug = slugify(text);\n\n    entries.push({\n      depth,\n      text,\n      slug,\n      children: [],\n    });\n  }\n\n  // Build nested structure\n  return buildTocTree(entries);\n}\n\n/**\n * Builds nested TOC tree from flat list.\n */\nfunction buildTocTree(entries: TocEntry[]): TocEntry[] {\n  const root: TocEntry[] = [];\n  const stack: TocEntry[] = [];\n\n  for (const entry of entries) {\n    // Pop stack until we find a parent with smaller depth\n    while (stack.length > 0 && stack[stack.length - 1].depth >= entry.depth) {\n      stack.pop();\n    }\n\n    if (stack.length === 0) {\n      root.push(entry);\n    } else {\n      stack[stack.length - 1].children.push(entry);\n    }\n\n    stack.push(entry);\n  }\n\n  return root;\n}\n\n/**\n * Converts text to URL-friendly slug.\n */\nfunction slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-')\n    .replace(/-+/g, '-')\n    .trim();\n}\n\n/**\n * Renders Markdown content to HTML.\n *\n * Uses @ox-content/napi for high-performance Rust-based rendering.\n * Falls back to a basic regex implementation if NAPI is not available.\n */\nasync function renderToHtml(content: string, options: ResolvedOptions): Promise<string> {\n  // Load and use NAPI bindings if available (Rust-based parser)\n  const napi = await loadNapiBindings();\n  if (napi) {\n    const result = napi.parseAndRender(content, {\n      gfm: options.gfm,\n    });\n    if (result.errors.length > 0) {\n      console.warn('[ox-content] Parse warnings:', result.errors);\n    }\n    return result.html;\n  }\n\n  // Fallback: basic regex-based rendering (for development when NAPI not built)\n  console.warn('[ox-content] NAPI bindings not available, using fallback renderer');\n  let html = content;\n\n  // Code blocks first (to prevent interference with other patterns)\n  html = html.replace(/```(\\w*)\\n([\\s\\S]*?)```/g, (_, lang, code) => {\n    const langClass = lang ? ` class=\"language-${lang}\"` : '';\n    return `\\n<pre><code${langClass}>${escapeHtml(code.trim())}</code></pre>\\n`;\n  });\n\n  // Tables (GFM)\n  html = html.replace(/^\\|(.+)\\|\\r?\\n\\|[-:| ]+\\|\\r?\\n((?:\\|.+\\|\\r?\\n?)+)/gm, (_, header, body) => {\n    const headerCells = header.split('|').map((c: string) => c.trim()).filter(Boolean);\n    const headerRow = headerCells.map((c: string) => `<th>${c}</th>`).join('');\n\n    const bodyRows = body.trim().split('\\n').map((row: string) => {\n      const cells = row.split('|').map((c: string) => c.trim()).filter(Boolean);\n      return `<tr>${cells.map((c: string) => `<td>${c}</td>`).join('')}</tr>`;\n    }).join('\\n');\n\n    return `<table>\\n<thead><tr>${headerRow}</tr></thead>\\n<tbody>\\n${bodyRows}\\n</tbody>\\n</table>\\n`;\n  });\n\n  // Headers with IDs for linking (h4, h3, h2, h1 in order)\n  html = html.replace(/^#### (.+)$/gm, (_, text) => `<h4 id=\"${slugify(text)}\">${text}</h4>`);\n  html = html.replace(/^### (.+)$/gm, (_, text) => `<h3 id=\"${slugify(text)}\">${text}</h3>`);\n  html = html.replace(/^## (.+)$/gm, (_, text) => `<h2 id=\"${slugify(text)}\">${text}</h2>`);\n  html = html.replace(/^# (.+)$/gm, (_, text) => `<h1 id=\"${slugify(text)}\">${text}</h1>`);\n\n  // Horizontal rules\n  html = html.replace(/^(---|\\*\\*\\*|___)\\s*$/gm, '<hr>');\n\n  // Blockquotes\n  html = html.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');\n  // Merge consecutive blockquotes\n  html = html.replace(/<\\/blockquote>\\n<blockquote>/g, '\\n');\n\n  // Bold and italic (order matters)\n  html = html.replace(/\\*\\*\\*(.+?)\\*\\*\\*/g, '<strong><em>$1</em></strong>');\n  html = html.replace(/\\*\\*(.+?)\\*\\*/g, '<strong>$1</strong>');\n  html = html.replace(/\\*([^*\\n]+)\\*/g, '<em>$1</em>');\n  html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');\n  html = html.replace(/_([^_\\n]+)_/g, '<em>$1</em>');\n\n  // Strikethrough (GFM)\n  html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');\n\n  // Inline code (after code blocks to prevent interference)\n  html = html.replace(/`([^`\\n]+)`/g, '<code>$1</code>');\n\n  // Links and images\n  html = html.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, '<img src=\"$2\" alt=\"$1\">');\n  html = html.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, '<a href=\"$2\">$1</a>');\n\n  // Task lists (GFM)\n  html = html.replace(/^(\\s*)- \\[x\\] (.+)$/gm, '$1<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled> $2</li>');\n  html = html.replace(/^(\\s*)- \\[ \\] (.+)$/gm, '$1<li class=\"task-list-item\"><input type=\"checkbox\" disabled> $2</li>');\n\n  // Unordered lists\n  html = html.replace(/^(\\s*)- (.+)$/gm, '$1<li>$2</li>');\n\n  // Ordered lists\n  html = html.replace(/^(\\s*)\\d+\\. (.+)$/gm, '$1<li>$2</li>');\n\n  // Wrap consecutive <li> elements in <ul> or <ol>\n  html = html.replace(/((?:<li[^>]*>.*<\\/li>\\n?)+)/g, (match) => {\n    // Check if it's a task list or regular list\n    if (match.includes('task-list-item')) {\n      return `<ul class=\"task-list\">\\n${match}</ul>\\n`;\n    }\n    return `<ul>\\n${match}</ul>\\n`;\n  });\n\n  // Split into blocks and wrap paragraphs\n  const blocks = html.split(/\\n\\n+/);\n  html = blocks.map(block => {\n    block = block.trim();\n    if (!block) return '';\n    // Don't wrap if it's already a block element\n    if (/^<(h[1-6]|p|div|ul|ol|li|table|thead|tbody|tr|th|td|pre|blockquote|hr|img)[\\s>]/i.test(block)) {\n      return block;\n    }\n    // Don't wrap if it ends with a block element\n    if (/<\\/(h[1-6]|p|div|ul|ol|table|pre|blockquote)>$/i.test(block)) {\n      return block;\n    }\n    return `<p>${block}</p>`;\n  }).join('\\n\\n');\n\n  // Clean up extra line breaks within paragraphs\n  html = html.replace(/<p>([\\s\\S]*?)<\\/p>/g, (_, content) => {\n    return `<p>${content.replace(/\\n/g, '<br>')}</p>`;\n  });\n\n  return `<div class=\"ox-content\">${html}</div>`;\n}\n\n/**\n * Escapes HTML special characters.\n */\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\n/**\n * Generates the JavaScript module code.\n */\nfunction generateModuleCode(\n  html: string,\n  frontmatter: Record<string, unknown>,\n  toc: TocEntry[],\n  filePath: string,\n  _options: ResolvedOptions\n): string {\n  const htmlJson = JSON.stringify(html);\n  const frontmatterJson = JSON.stringify(frontmatter);\n  const tocJson = JSON.stringify(toc);\n\n  return `\n// Generated by vite-plugin-ox-content\n// Source: ${filePath}\n\n/**\n * Rendered HTML content.\n */\nexport const html = ${htmlJson};\n\n/**\n * Parsed frontmatter.\n */\nexport const frontmatter = ${frontmatterJson};\n\n/**\n * Table of contents.\n */\nexport const toc = ${tocJson};\n\n/**\n * Default export with all data.\n */\nexport default {\n  html,\n  frontmatter,\n  toc,\n};\n\n// HMR support\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (newModule) {\n      // Trigger re-render with new content\n      import.meta.hot.invalidate();\n    }\n  });\n}\n`;\n}\n\n/**\n * Extracts imports from Markdown content.\n *\n * Supports importing components for interactive islands.\n */\nexport function extractImports(content: string): string[] {\n  const importRegex = /^import\\s+.+\\s+from\\s+['\"](.+)['\"]/gm;\n  const imports: string[] = [];\n  let match;\n\n  while ((match = importRegex.exec(content)) !== null) {\n    imports.push(match[1]);\n  }\n\n  return imports;\n}\n","/**\n * Source documentation extraction and generation.\n *\n * Extracts JSDoc/TSDoc comments from source files and generates\n * Markdown documentation automatically.\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport type { ResolvedDocsOptions, ExtractedDocs, DocEntry, ParamDoc } from './types';\n\n// Regex patterns for JSDoc extraction\nconst JSDOC_BLOCK = /\\/\\*\\*\\s*([\\s\\S]*?)\\s*\\*\\//g;\nconst FUNCTION_DECL = /(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)/;\nconst CONST_FUNC = /(?:export\\s+)?const\\s+(\\w+)\\s*=\\s*(?:async\\s*)?\\(/;\nconst CLASS_DECL = /(?:export\\s+)?class\\s+(\\w+)/;\nconst INTERFACE_DECL = /(?:export\\s+)?interface\\s+(\\w+)/;\nconst TYPE_DECL = /(?:export\\s+)?type\\s+(\\w+)/;\n\n/**\n * Extracts documentation from source files in directories.\n */\nexport async function extractDocs(\n  srcDirs: string[],\n  options: ResolvedDocsOptions\n): Promise<ExtractedDocs[]> {\n  const results: ExtractedDocs[] = [];\n\n  for (const srcDir of srcDirs) {\n    const files = await findFiles(srcDir, options);\n\n    for (const file of files) {\n      const content = await fs.promises.readFile(file, 'utf-8');\n      const entries = extractFromContent(content, file, options);\n\n      if (entries.length > 0) {\n        results.push({ file, entries });\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Finds all matching files in a directory.\n */\nasync function findFiles(dir: string, options: ResolvedDocsOptions): Promise<string[]> {\n  const files: string[] = [];\n\n  async function walk(currentDir: string) {\n    let entries;\n    try {\n      entries = await fs.promises.readdir(currentDir, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    for (const entry of entries) {\n      const fullPath = path.join(currentDir, entry.name);\n\n      if (entry.isDirectory()) {\n        if (!isExcluded(fullPath, options.exclude)) {\n          await walk(fullPath);\n        }\n      } else if (entry.isFile()) {\n        if (isIncluded(fullPath, options.include) && !isExcluded(fullPath, options.exclude)) {\n          files.push(fullPath);\n        }\n      }\n    }\n  }\n\n  await walk(dir);\n  return files;\n}\n\nfunction isIncluded(file: string, patterns: string[]): boolean {\n  return patterns.some((pattern) => {\n    if (pattern.includes('**')) {\n      const ext = pattern.split('.').pop();\n      return file.endsWith(`.${ext}`);\n    }\n    return file.endsWith(pattern.replace('*', ''));\n  });\n}\n\nfunction isExcluded(file: string, patterns: string[]): boolean {\n  return patterns.some((pattern) => {\n    if (pattern.includes('node_modules')) {\n      return file.includes('node_modules');\n    }\n    if (pattern.includes('.test.') || pattern.includes('.spec.')) {\n      return file.includes('.test.') || file.includes('.spec.');\n    }\n    return false;\n  });\n}\n\n/**\n * Extracts documentation entries from file content.\n */\nfunction extractFromContent(\n  content: string,\n  file: string,\n  options: ResolvedDocsOptions\n): DocEntry[] {\n  const entries: DocEntry[] = [];\n\n  let match: RegExpExecArray | null;\n  JSDOC_BLOCK.lastIndex = 0;\n\n  while ((match = JSDOC_BLOCK.exec(content)) !== null) {\n    const jsdocContent = match[1];\n    const jsdocEnd = match.index + match[0].length;\n\n    const afterJsdoc = content.slice(jsdocEnd).trim();\n    const lineNumber = content.slice(0, match.index).split('\\n').length;\n\n    const entry = parseJsdocBlock(jsdocContent, afterJsdoc, file, lineNumber);\n\n    if (entry && (options.private || !entry.private)) {\n      entries.push(entry);\n    }\n  }\n\n  return entries;\n}\n\n/**\n * Parses a JSDoc block and the following declaration.\n */\nfunction parseJsdocBlock(\n  jsdoc: string,\n  declaration: string,\n  file: string,\n  line: number\n): DocEntry | null {\n  const params: ParamDoc[] = [];\n  const examples: string[] = [];\n  const tags: Record<string, string> = {};\n  let description = '';\n  let returns: { type: string; description: string } | undefined;\n  let isPrivate = false;\n\n  const cleanedLines = jsdoc\n    .split('\\n')\n    .map((l) => l.replace(/^\\s*\\*\\s?/, '').trim())\n    .filter((l) => l);\n\n  let currentExample = '';\n  let inExample = false;\n\n  for (const lineText of cleanedLines) {\n    if (lineText.startsWith('@')) {\n      if (inExample) {\n        examples.push(currentExample.trim());\n        currentExample = '';\n        inExample = false;\n      }\n\n      const tagMatch = /@(\\w+)\\s*(?:\\{([^}]*)\\})?(.*)/.exec(lineText);\n      if (tagMatch) {\n        const [, tagName, tagType, tagRest] = tagMatch;\n\n        switch (tagName) {\n          case 'param':\n            const paramMatch = /(\\w+)\\s*-?\\s*(.*)/.exec(tagRest.trim());\n            if (paramMatch) {\n              params.push({\n                name: paramMatch[1],\n                type: tagType || 'unknown',\n                description: paramMatch[2],\n              });\n            }\n            break;\n          case 'returns':\n          case 'return':\n            returns = {\n              type: tagType || 'unknown',\n              description: tagRest.trim(),\n            };\n            break;\n          case 'example':\n            inExample = true;\n            break;\n          case 'private':\n            isPrivate = true;\n            break;\n          default:\n            tags[tagName] = tagRest.trim();\n        }\n      }\n    } else if (inExample) {\n      currentExample += lineText + '\\n';\n    } else if (!description) {\n      description = lineText;\n    } else {\n      description += ' ' + lineText;\n    }\n  }\n\n  if (inExample && currentExample) {\n    examples.push(currentExample.trim());\n  }\n\n  let name = '';\n  let kind: DocEntry['kind'] = 'function';\n\n  let declMatch: RegExpExecArray | null;\n\n  if ((declMatch = FUNCTION_DECL.exec(declaration))) {\n    name = declMatch[1];\n    kind = 'function';\n  } else if ((declMatch = CONST_FUNC.exec(declaration))) {\n    name = declMatch[1];\n    kind = 'function';\n  } else if ((declMatch = CLASS_DECL.exec(declaration))) {\n    name = declMatch[1];\n    kind = 'class';\n  } else if ((declMatch = INTERFACE_DECL.exec(declaration))) {\n    name = declMatch[1];\n    kind = 'interface';\n  } else if ((declMatch = TYPE_DECL.exec(declaration))) {\n    name = declMatch[1];\n    kind = 'type';\n  }\n\n  if (!name) return null;\n\n  return {\n    name,\n    kind,\n    description,\n    params: params.length > 0 ? params : undefined,\n    returns,\n    examples: examples.length > 0 ? examples : undefined,\n    tags: Object.keys(tags).length > 0 ? tags : undefined,\n    private: isPrivate,\n    file,\n    line,\n  };\n}\n\n/**\n * Generates Markdown documentation from extracted docs.\n */\nexport function generateMarkdown(\n  docs: ExtractedDocs[],\n  options: ResolvedDocsOptions\n): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  if (options.groupBy === 'file') {\n    for (const doc of docs) {\n      const fileName = path.basename(doc.file, path.extname(doc.file));\n      const markdown = generateFileMarkdown(doc, options);\n      result[`${fileName}.md`] = markdown;\n    }\n\n    result['index.md'] = generateIndex(docs);\n  } else {\n    const byKind = new Map<string, DocEntry[]>();\n\n    for (const doc of docs) {\n      for (const entry of doc.entries) {\n        const existing = byKind.get(entry.kind) || [];\n        existing.push(entry);\n        byKind.set(entry.kind, existing);\n      }\n    }\n\n    for (const [kind, entries] of byKind) {\n      result[`${kind}s.md`] = generateCategoryMarkdown(kind, entries, options);\n    }\n\n    result['index.md'] = generateCategoryIndex(byKind);\n  }\n\n  return result;\n}\n\nfunction generateFileMarkdown(doc: ExtractedDocs, options: ResolvedDocsOptions): string {\n  const fileName = path.basename(doc.file);\n  let md = `# ${fileName}\\n\\n`;\n\n  if (options.toc && doc.entries.length > 1) {\n    md += '## Table of Contents\\n\\n';\n    for (const entry of doc.entries) {\n      md += `- [${entry.name}](#${entry.name.toLowerCase()})\\n`;\n    }\n    md += '\\n---\\n\\n';\n  }\n\n  for (const entry of doc.entries) {\n    md += generateEntryMarkdown(entry);\n  }\n\n  return md;\n}\n\nfunction generateEntryMarkdown(entry: DocEntry): string {\n  let md = `## ${entry.name}\\n\\n`;\n\n  md += `\\`${entry.kind}\\`\\n\\n`;\n\n  if (entry.description) {\n    md += `${entry.description}\\n\\n`;\n  }\n\n  if (entry.params && entry.params.length > 0) {\n    md += '### Parameters\\n\\n';\n    md += '| Name | Type | Description |\\n';\n    md += '|------|------|-------------|\\n';\n    for (const param of entry.params) {\n      md += `| \\`${param.name}\\` | \\`${param.type}\\` | ${param.description} |\\n`;\n    }\n    md += '\\n';\n  }\n\n  if (entry.returns) {\n    md += '### Returns\\n\\n';\n    md += `\\`${entry.returns.type}\\` - ${entry.returns.description}\\n\\n`;\n  }\n\n  if (entry.examples && entry.examples.length > 0) {\n    md += '### Examples\\n\\n';\n    for (const example of entry.examples) {\n      md += '```ts\\n';\n      md += example.replace(/^```\\w*\\n?/, '').replace(/\\n?```$/, '');\n      md += '\\n```\\n\\n';\n    }\n  }\n\n  md += '---\\n\\n';\n\n  return md;\n}\n\nfunction generateIndex(docs: ExtractedDocs[]): string {\n  let md = '# API Documentation\\n\\n';\n  md += 'Generated by [Ox Content](https://github.com/ubugeeei/ox-content)\\n\\n';\n\n  md += '## Modules\\n\\n';\n\n  for (const doc of docs) {\n    const fileName = path.basename(doc.file, path.extname(doc.file));\n    md += `### [${fileName}](./${fileName}.md)\\n\\n`;\n\n    for (const entry of doc.entries) {\n      const desc = entry.description?.slice(0, 80) || '';\n      const ellipsis = entry.description && entry.description.length > 80 ? '...' : '';\n      md += `- \\`${entry.kind}\\` **${entry.name}** - ${desc}${ellipsis}\\n`;\n    }\n    md += '\\n';\n  }\n\n  return md;\n}\n\nfunction generateCategoryMarkdown(\n  kind: string,\n  entries: DocEntry[],\n  options: ResolvedDocsOptions\n): string {\n  let md = `# ${kind.charAt(0).toUpperCase() + kind.slice(1)}s\\n\\n`;\n\n  if (options.toc) {\n    md += '## Table of Contents\\n\\n';\n    for (const entry of entries) {\n      md += `- [${entry.name}](#${entry.name.toLowerCase()})\\n`;\n    }\n    md += '\\n---\\n\\n';\n  }\n\n  for (const entry of entries) {\n    md += generateEntryMarkdown(entry);\n  }\n\n  return md;\n}\n\nfunction generateCategoryIndex(byKind: Map<string, DocEntry[]>): string {\n  let md = '# API Documentation\\n\\n';\n  md += 'Generated by [Ox Content](https://github.com/ubugeeei/ox-content)\\n\\n';\n\n  for (const [kind, entries] of byKind) {\n    const kindTitle = kind.charAt(0).toUpperCase() + kind.slice(1) + 's';\n    md += `## [${kindTitle}](./${kind}s.md)\\n\\n`;\n\n    for (const entry of entries) {\n      const desc = entry.description?.slice(0, 60) || '';\n      md += `- **${entry.name}** - ${desc}...\\n`;\n    }\n    md += '\\n';\n  }\n\n  return md;\n}\n\n/**\n * Writes generated documentation to the output directory.\n */\nexport async function writeDocs(\n  docs: Record<string, string>,\n  outDir: string\n): Promise<void> {\n  await fs.promises.mkdir(outDir, { recursive: true });\n\n  for (const [fileName, content] of Object.entries(docs)) {\n    const filePath = path.join(outDir, fileName);\n    await fs.promises.writeFile(filePath, content, 'utf-8');\n  }\n}\n\n/**\n * Resolves docs options with defaults.\n */\nexport function resolveDocsOptions(\n  options: import('./types').DocsOptions | false | undefined\n): ResolvedDocsOptions | false {\n  if (options === false) {\n    return false;\n  }\n\n  const opts = options || {};\n\n  return {\n    enabled: opts.enabled ?? true,\n    src: opts.src ?? ['./src'],\n    out: opts.out ?? 'docs/api',\n    include: opts.include ?? ['**/*.ts', '**/*.tsx'],\n    exclude: opts.exclude ?? ['**/*.test.*', '**/*.spec.*', 'node_modules'],\n    format: opts.format ?? 'markdown',\n    private: opts.private ?? false,\n    toc: opts.toc ?? true,\n    groupBy: opts.groupBy ?? 'file',\n  };\n}\n"],"mappings":"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","names":["path","rehypeParse","rehypeStringify","import_unified","import_rehype_parse","import_rehype_stringify","getTextContent","rehypeParse","rehypeStringify","content","path"]}